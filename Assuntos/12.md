## Matrizes

Matrizes são vetores multidimensionais. 
Em algumas linguagens, vetores e matrizes só podem ser declarados com tamanho conhecido em tempo de compilação.
Essa restrição pode ser muito limitante em várias situações mais dinâmicas, em que o programa só sabe das susas necessidades em tempo de execução.

Em outras linguagens, o tamanho de vetores e matrizes pode ser definido em tempo de execução, mas não pode ser alterado uma vez declarados.
A linguagem C, a partir da padronização C99 pormite esse tipo de declaração, como abaixo:
```c
  int nl, nc;
  scanf("%d %d", &nl, &nc);
  double mat[nl][nc]; // uma matriz assim não pode ser inicializada com "= { ... }"
```

Algumas linguagens têm vetores e matrizes redimensionáveis.
Não é o caso de C. No caso de vetores, é simples de implementar com alocação e realocação dinâmica, como já vimos.
No caso de matrizes, a alocação dinâmica é um tanto menos simples, e tem várias possibilidades, todas com vantagens e desvantagens em relação às demais.

Quando o número de colunas é fixo e conhecido em tempo de compilação, dá para usar um método semelhante ao usado para vetores, considerando que um vetor pode ser implementado por um ponteiro para um elemento, e os demais elementos seguem nas posições seguintes da memória:
```c
   tipo *p;
   p = malloc(n*sizeof(tipo));
   // p[i] é um valor do tipo "tipo" 
```
Declarando "tipo" como um inteiro, podemos tratar "p" como um vetor de inteiros:
```c
   typedef int tipo;            // "tipo" é um inteiro
   tipo *p;                     // "p" é um ponteiro para inteiro
   p = malloc(n*sizeof(tipo));  // "p" aponta para o primeiro de "n" inteiros
   // p[i] é um dos inteiros apontados por "p", um valor do tipo "int" 
```
Se o "tipo" for declarado como um vetor de inteiros, podemos tratar "p" como um vetor de vetores de inteiros:
```c
   typedef int tipo[100];       // "tipo" é um vetor de 100 inteiros
   tipo *p;                     // "p" é um ponteiro para vetor de 100 inteiros
   p = malloc(n*sizeof(tipo));  // "p" aponta para o primeiro de "n" vetores de 100 inteiros
   // p[i] é um dos vetores apontados por "p", um valor do tipo "vetor de 100 int"
   // p[i][j] é um dos inteiros desse vetor, um valor do tipo "int"
```

Uma matriz implementada dessa forma pode ser redimensionada no número de linhas, da mesma forma que um vetor alocado dinamicamente pode ser redimensionado.
Nessa implementação, todos os dados da matriz ficam contíguos em memória, o que geralmente melhora o desempenho no acesso, por não necessitar acessar um ponteiro intermediário (como é o caso da próxima solução), e por nao impor sobrecarga extra no sistema de memória *cache*, que geralmente acontece quando os dados da matriz estão mais espalhados pela memória.
Por outro lado, caso seja necessário suporte ao redimensionamento das duas dimensões, esse método não funciona.

Uma forma usual de se implementar uma matriz bidimensional em C, que pode ser livremente redimensionada é usar um vetor dinâmico de ponteiros para vetores dinâmicos. Cada linha de valores é alocada independentemente, e pode ser realocada quando necessário, e a matriz é representada por um vetor de ponteiros para essas linhas. Em código, a alocação de uma matriz de *m*x*n* *double*s poderia ser assim:
```c
   double **mat;
   mat = malloc(m * sizeof(double *)); // aloca vetor com m ponteiros
   for (int i=0; i<m; i++) {
     mat[i] = malloc(n * sizeof(double)); // aloca espaço para a i-ésima linha
   }
   m[3][4] = 23; // por causa da sintaxe de acesso a ponteiros, 
                 //  a sintaxe de acesso aos elementos da matriz é igual à de matrizes "normais"
```
Essa forma suporta inclusive que linhas diferentes tenham tamanhos diferentes, permitindo, por exemplo, a implementação de matrizes triangulares. A grande desvantagem, além da complexidade de alocação e liberação da memória (e o gasto de tempo e memória que isso envolve), está no custo em desempenho, pela necessidade de acesso ao ponteiro de linha e à sobrecarga causada ao sistema cde memória *cache*.

Uma forma parecida, mas que diminui as desvantagens de número de alocações e liberações de memória, além de manter os dados contíguos é fazer a alocação de todos os dados em um único bloco de memória, e apontar os ponteiros de linha para posições no interior desse bloco:
```c
   double **mat;
   mat = malloc(m * sizeof(double *)); // aloca vetor com m ponteiros
   mat[0] = malloc(m * n * sizeof(double)); // aloca espaço para todos os dados da matriz
   for (int i=1; i<m; i++) {
     mat[i] = mat[0] + i * n; // aponta o i-ésimo ponteiro para o início da linha no bloco
   }
   m[3][4] = 23; // por causa da sintaxe de acesso a ponteiros, 
                 //  a sintaxe de acesso aos elementos da matriz é igual à de matrizes "normais"
```

Uma outra forma de alocação da matriz é realizar a alocação de todos os elementos como um vetor, e acessar os elementos calculando o índice nesse vetor à partir dos número de linha e coluna que se quer acessar. Com isso, evita-se o acesso a um vetor intermediário, mas em compensação perde-se a sintaxe de matriz para o acesso aos elementos, em geral substituindo-se por um acesso através de funções:
```c
   double *mat;
   mat = malloc(m * n * sizeof(double)); // aloca espaço para todos os dados da matriz
   poe_na_matriz(m, 3, 4, 23);
   // ou
   mat[ind(3, 4)] = 23;
   
   // o calculo do indice seria algo como:
int ind(int lin, int col) {
  return mat + lin*n + col;
}
   // ou, se tem a matriz tem um descritor:
int ind(matriz *mat, int lin, int col) {
  return mat->dados + lin*mat->n_col + col;
}
```

*...continua...*
