### Terceira aula de ED

Tivemos a continuação da revisão de C iniciada na aula anterior.
A aula foi centrada no desenvolvimento/aperfeiçoamento do exercício da aula anterior.
No final, chegamos a uma versão do programa que implementa (acho) o que é pedido no terceiro exercício (veja abaixo).
Coloquei alguns comentários pra tentar ajudar.
Dúvidas sobre o código, manda mail!

```c
#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <stdlib.h>


void gravar_arquivo(char *nome, char **vetor, int n)
{
    FILE *arq;

    arq = fopen(nome, "w");
    if (arq == NULL) {
        printf("Problema na criacao do arquivo de saida\n");
        return;
    }
    for (int i=0; i<n; i++) {
        // as strings não têm \n no final, mas tem que ter no arquivo.
        fprintf(arq, "%s\n", vetor[i]);
    }
    fclose(arq);
}

char *le_linha(FILE *arq)
{
    char *lin;
    int p = 0;  // posicao na linha onde vai ser colocado o proximo caractere.
    int n = 35; // tamanho do espaço total para a linha sendo lida.
    
    lin = malloc(n);
    while (true) {
        int c = getc(arq);
        if (c == '\n') {
            // fim da linha, a string em lin está completa (falta o \0)(e sem o \n)
            break;
        }
        if (c == EOF) {
            if (p == 0) {
                // o arquivo terminou no início de uma linha (quer dizer que essa linha não existe)
                free(lin);
                return NULL;
            }
            // o arquivo terminou no meio de uma linha -- trata como se tivesse visto um \n
            break;
        }
        // foi lido um caractere normal -- coloca no final da linha que está sendo lida.
        lin[p] = c;
        p++;
        if (p >= n) {
            // a linha é maior que o espaço que temos -- realoca
            n *= 2;
            lin = realloc(lin, n);
            if (lin == NULL) {
                printf("faltou memoria");
                exit(1);
            }
        }
    }
    lin[p] = '\0';
    // lin tem n bytes alocados, a string precisa de somente p+1 bytes -- devolve o excesso pro sistema
    if (n != p+1) {
      lin = realloc(lin, p+1);
      if (lin == NULL) {
          printf("faltou memoria");
          exit(1);
      }
    }
    return lin;
}

int ler_arquivo(char *nome, char **vetor, int n)
{
    FILE *arq;

    arq = fopen(nome, "r");
    if (arq == NULL) {
        printf("Problema na abertura do arquivo de entrada\n");
        return 0;
    }
    for (int i=0; i<n; i++) {
        char *lin = le_linha(arq);
        if (lin == NULL) {
            return i;
        }
        vetor[i] = lin;
    }
    fclose(arq);
    return n;
}

int conta_linhas_no_arquivo(char *nome)
{
    FILE *arq;
    int n = 0;
    bool to_no_inicio_da_linha = true;

    arq = fopen(nome, "r");
    if (arq == NULL) {
        printf("Problema na abertura do arquivo de entrada\n");
        return 0;
    }
    while (true) {
        int c = getc(arq);
        if (c == EOF) break;
        if (to_no_inicio_da_linha) {
            n++;
        }
        to_no_inicio_da_linha = (c == '\n');
    }
    fclose(arq);
    return n;
}

bool maiuscula(char c)
{
    return c >= 'A' && c <= 'Z';
}

bool minuscula(char c)
{
    return c >= 'a' && c <= 'z';
}

bool letra(char c)
{
    return maiuscula(c) || minuscula(c);
}

char vira_minuscula(char c)
{
    if (!maiuscula(c)) return c;
    return c - 'A' + 'a';
}

void minusculiza_des(char *nome)
{
    // TODO: suporte para mais partículas
    char *des[] = { "De ", "Dos ", "Da " };
    for (int i=0; i<3; i++) {
        char *de;
        do {
            de = strstr(nome, des[i]);
            if (de != NULL) {
                *de = vira_minuscula(*de);
            }
        } while (de != NULL);
    }
}

void converte_nome(char *nome)
{
    char *p = nome;
    bool transforma = false;

    while (*p != '\0') {
        if (maiuscula(*p) && transforma) {
            *p = vira_minuscula(*p);
        }
        transforma = letra(*p);
        p++;
    }
    minusculiza_des(nome);
}

int main()
{
    typedef char *str;
    str *nomes;
    
    int n, n2;
    n = conta_linhas_no_arquivo("maius");
    nomes = malloc(n*sizeof(str));
    if (nomes == NULL) {
        printf("memoria insuficiente");
        exit(1);
    }
    n2 = ler_arquivo("maius", nomes, n);
    if (n != n2) {
        printf("deu problema!\ncontrate um programador melhor.\n");
        exit(1);
    }
    for (int i=0; i<n; i++) {
        converte_nome(nomes[i]);
    }
    gravar_arquivo("saida", nomes, n);
    free(nomes);
    return 0;
}
```

### Trabalho 1

O programa acima tem um problema sério de legibilidade, principalmente na função main, que contém um excesso de detalhes, que torna a função bem mais difícil de ser entendida do que se espera para um programa tão simples.
A implementação deveria refletir mais diretamente o algoritmo que descreve o que o programa deve fazer (ler o arquivo de strings, alterar as strings, gravar o arquivo com as strings alteradas.
Uma forma mais clara de implementar essa função poderia ser:

```c
int main()
{
  vetor_de_linhas *nomes;
  
  nomes = le_linhas_de_arquivo("entrada");
  minusculiza_linhas(nomes);
  grava_linhas_em_arquivo(linhas, "saida");
  
  libera_memoria_de_linhas(linhas);
  
  return 0;
}
```

O trabalho 1 consiste em completar o programa acima, sem alterar a função `main`.
Para isso, você deve criar o tipo `vetor_de_linhas`, que é usado por todas as funções chamadas por `main`, e deve concentrar as informações que essas funções necessitam (provavelmente vai ser uma struct).
Você pode usar o que quiser do programa visto em aula.

Entrega: envie um mail, no qual está anexado o arquivo .c com o programa implementado, para benhur+ed21a@inf.ufsm.br.
O nome do arquivo deve ser t1-fulano.c; o assunto do mail deve ser t1-ed-fulano; o mail deve ser enviado antes da aula do dia 31mai.
"fulano" é o login no domínio inf.
A primeira linha do programa deve ser um comentário com o nome do aluno.
O programa deve executar no gdb online, sem warnings.

### Alocação dinâmica de memória

Um dos assuntos vistos foi alocação dinâmica de memória, que alguns alunos comentaram que não tinham visto ainda.
Segue abaixo o texto que coloquei sobre esse assunto para a turma de lab1 do semestre passado.
Vendo melhor agora o texto abaixo, que tem um exemplo que deve ter tido apoio do que foi visto em aula, talvez não seja tão simples de entender.

Vi também que faltou explicar a função `realloc`, que permite alterar o tamanho da memória que foi alocada por `malloc`, tanto para aumentar quanto para reduzir a área de memória. Ela retorna um ponteiro para a nova área; o conteúdo da memória da área original é copiado para a nova área; a memória da área original é liberada e não deve mais ser usada.

Como sempre, qualquer dúvida pode ser resolvida por mail.
Se quiserem, podemos fazer uma aula (talvez em horário alternativo) para reforçar o assunto.

------

A forma principal de abstração para a memória da linguagem C são as variáveis.
A criação de uma variável é uma forma organizada de se dizer ao compilador que se quer um tanto de memória, que esse tanto vai ser usado para armazenar dados de um determinado tipo, que vai passar a ser referenciado por tal nome dentro do programa.
O compilador vai então verificar que todo o uso dessa memória é realizado de acordo com esse "contrato", e vai tentar otimizar a quantidade de memória necessária para esse uso (por exemplo, quando uma função começa sua execução, suas variáveis precisam de memória, mas quando uma função termina de executar, essas variáveis não são mais necessárias, e a memória que elas estão utilizando pode ser reutilizada para outra coisa -- isso é feito automaticamente pelo compilador).

Mas essa forma de usar memória por vezes tem limitações, e em algumas situações surge a necessidade de se ter um controle maior sobre o uso da memória.
Por exemplo, para poder usar memória além da pré-definida pelas variáveis presentes no programa (pense em um programa que só vai poder definir quanto de memória vai precisar depois que já está executando, porque lê dados de um arquivo, por exemplo), ou para organizar o uso da memória de uma forma diferente da imposta pela alocação e liberação ligada automaticamente à ordem de execução das funções (uma função que cria uma variável e gostaria que ela pudesse ser usada pela função que a chamou, por exemplo).

Para esses casos, tem-se a alocação explícita de memória (mais conhecida como alocação dinâmica, que é um nome pior, porque a alocação automática feita pelo mecanismo de execução das funções também é dinâmica).
Nessa forma de alocação de memória, é o programador quem realiza a alocação e a liberação da memória, no momento que considerar mais adequado.
Essa memória é por vezes chamada de anônima, porque não é vinculada a uma variável com nome pré-definido.

Como essa memória não é associada a variáveis, a forma que se tem para usar esse tipo de memória é através de ponteiros.

Existem duas operações principais de manipulação desse tipo de memória: a operação de alocação e a operação de liberação de memória.
Quando se aloca memória, se diz quanto de memória se quer (quantos bytes), e se recebe do sistema esse tanto de memória, na forma de um ponteiro para a primeira posição do bloco de memória alocado. As demais posições seguem essa primeira, de forma contígua, como em um vetor.
Para se liberar a memória, passa-se um ponteiro para essa mesma posição, o sistema sabe quanto de memória foi alocada e faz o necessário para disponibilizar essa memória para outros usos.
Depois de liberado, o bloco de memória não pode mais ser utilizado.

Essas operações estão disponibilizadas em C na forma de funções, acessíveis incluindo-se `stdlib.h`.
Essas funções são `malloc` e `free`.
A função `malloc` recebe um único argumento, que é a quantidade de bytes que se deseja, e retorna um ponteiro para a região alocada, que tem esse número de bytes disponíveis. Caso a alocação não seja possível, o ponteiro retornado tem um valor especial, chamado `NULL`. Sempre deve-se testar o valor retornado por `malloc` para verificar se a alocação de memória foi bem sucedida.

A função `free` recebe um único argumento, que é um ponteiro para a primeira posição de memória do bloco a ser liberado, obrigatoriamente o mesmo valor retornado por um pedido de alocação de memória anterior.

Não existe limitação no tamanho de um bloco a alocar, nem na quantidade de blocos alocados, a não ser a quantidade de memória disponível.

Para facilitar o cálculo da quantidade de memória, existe o operador `sizeof`, que dá o número de bytes usado por qualquer tipo de dados. Por exemplo, `sizeof(double)` diz quantos bytes de memória são necessário para se armazenar um valor do tipo `double`.

Como a memória alocada é contígua, uma forma usual de se usar a memória alocada é como um vetor. Como vimos anteriormente, o uso de um vetor através de um ponteiro é muito semelhante (pra não dizer igual) ao uso de um vetor diretamente. O fato de o ponteiro estar apontando para memória alocada explicitamente ou estar apontando para memória que pertence a um vetor de verdade não muda a forma de uso.

Por exemplo, para se alocar memória para se usar como um vetor de tamanho definido pelos dados, pode-se usar algo como:

```c
#include <stdio.h>
#include <stdlib.h>

float calcula(int n, float v[n])
{
  // faz um cálculo complicado sobre os elementos do vetor
  float t=0;
  for (int i=0; i<n; i++) {
    t += v[i];
  }
  return t/n;
}

int main()
{
  float *vet;
  int n;
  printf("Quantos dados? ");
  scanf("%d" , &n);

  vet = malloc(n * sizeof(float));
  if (vet == NULL) {
    printf("Me recuso a ser explorado dessa forma vil!\n");
    return 5;
  }

  // a partir daqui, vet pode ser usado como se fosse um vetor de tamanho n
  for (int i=0; i<n; i++) {
    printf("digite o dado %d ", i);
    scanf("%f", &vet[i]);
  }
  float resultado = calcula(n, vet);
  printf("O resultado do cálculo é: %f\n", resultado);
  free(vet);
  // a partir daqui, a região apontada por vet não pode mais ser usada.
  return 0;
}
```

#### Versão alterada do programa da aula anterior

```c
#include <stdio.h>
#include <math.h>
#include <stdbool.h>
#include <string.h>
#include <stdlib.h>

typedef struct {
    char nome[50];
    float nota;
} aluno;

bool le_aluno(FILE *arq, aluno *a)
{
    if (fscanf(arq, "%s %f", a->nome, &a->nota) == 2) {
        return true;
    } else {
        return false;
    }
}

bool grava_aluno(FILE *arq, aluno *a)
{
    if (fprintf(arq, "%s %f\n", a->nome, a->nota) >= 0) {
        return true;
    } else {
        return false;
    }
}

aluno *le_cadastro(int *num, char nome[])
{
    FILE *arq;
    int i;
    arq = fopen(nome, "r");
    if (arq == NULL) {
        return 0;
    }
    int n;
    fscanf(arq, "%d", &n);
    aluno *v;
    v = malloc(n*sizeof(aluno));
    if (v == NULL) {
        printf("erro de alocacao de memoria");
        exit(1);
    }
    for (i = 0; i < n; i++) {
        if (!le_aluno(arq, &v[i])) {
            break;
        }
    }
    fclose(arq);
    *num = i;
    return v;
}

void grava_cadastro(int n, aluno v[], char nome[])
{
    FILE *arq;
    int i;
    bool deu_tudo_certo = true;
    char nome_tmp[100];
    sprintf(nome_tmp, "%s.tmp", nome);
    arq = fopen(nome_tmp, "w");
    if (arq == NULL) {
        printf("nao consegui abrir arquivo para gravacao\n");
        return;
    }
    fprintf(arq, "%d\n", n);
    for (i = 0; i < n; i++) {
        if (!grava_aluno(arq, &v[i])) {
            printf("Erro na gravacao\n");
            deu_tudo_certo = false;
            break;
        }
    }
    fclose(arq);
    if (deu_tudo_certo) {
        if (rename(nome_tmp, nome) != 0) {
            printf("erro na gravacao (rename)\n");
        }
    } else {
        remove(nome_tmp);
    }
}

void imprime_aluno(aluno a)
{
    printf("%-20.20s%5.1f\n", a.nome, a.nota);
}

void imprime_dados_interessantes(int n, aluno v[])
{
    for (int i=0; i<n; i++) {
        if (v[i].nota < 7) {
            imprime_aluno(v[i]);
        }
    }
}
int acha_aluno(int n, aluno v[], char nome[])
{
    for (int i=0; i<n; i++) {
        if (strcmp(v[i].nome, nome) == 0) {
            return i;
        }
    }
    return -1;
}
int xmain()
{
    aluno *cadastro;
    int nalunos;
    cadastro = le_cadastro(&nalunos, "alunos");
    imprime_dados_interessantes(nalunos, cadastro);
    return 0;
}

int main()
{
    aluno *cadastro;
    int nalunos;
    cadastro = le_cadastro(&nalunos, "alunos");
    char nome[50];
    printf("Nome do aluno: ");
    scanf("%s", nome);
    int p = acha_aluno(nalunos, cadastro, nome);
    if (p == -1) {
        printf("Aluno %s nao existe\ndeseja inclui-lo? ", nome);
        char resposta;
        scanf(" %c", &resposta);
        if (resposta == 's') {
            float nota;
            printf("Digite a nota: ");
            scanf("%f", &nota);
            aluno *nc;
            nalunos++;
            nc = realloc(cadastro, nalunos*sizeof(aluno));
            if (nc == NULL) {
                printf("erro na alocacao\n");
                exit(1);
            }
            cadastro = nc;
            strcpy(cadastro[nalunos-1].nome, nome);
            cadastro[nalunos-1].nota = nota;
            grava_cadastro(nalunos, cadastro, "alunos");
        }
    } else {
        float nota;
        printf("O aluno %s tem nota %.1f. Nova nota: ", nome, cadastro[p].nota);
        scanf("%f", &nota);
        cadastro[p].nota = nota;
        grava_cadastro(nalunos, cadastro, "alunos");
    }
    imprime_dados_interessantes(nalunos, cadastro);
    free(cadastro);
    return 0;
}

```
