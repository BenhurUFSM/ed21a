## Trabalho final

Você deve desenvolver um programa, que implementa uma simulação de planetas (ou outros corpos que gravitam), como descrito abaixo.

O programa deverá ser desenvolvido com a biblioteca [allegro](https://liballeg.org/), acessada através das funções descritas em ``tela.h``, implementadas em `tela.c` e exemplificadas em `exemplo1.c`, contidas no arquivo [tela.tgz](https://github.com/BenhurUFSM/ed21a/blob/main/Complementos/tela.tgz).
Instale allegro, veja se o exemplo funciona, familiarize-se com as funções, esclareça dúvidas, enquanto o programa é definido.

O arquivo contém também o programa `exemplo2.c`, que simula um grupo de planetas que se movem mais ou menos de acordo com as leis de gravitação de Newton, em duas dimensões.
Existe também suporte a uma força de ligação interplanetária, que afeta esse movimento (tem um comentário em um define no início do programa, descomente para habilitar).

O programa deve ser alterado para que os planetas sejam gerenciados por um grafo (os planetas são os nós desse grafo).
O número, tamanho, posição, velocidade inicial etc dos planetas deve ser escolhido aleatoriamente no início do programa.
Sugiro que não sejam escolhidos valores aleatórios muito radicais, ou a simulação pode ter problemas.
As ligações interplanetárias são arestas nesse grafo, e devem poder ser adicionadas/removidas pelo usuário.
Os planetas são identificados por letras, e uma aresta pode ser incluída digitando-se 3 caracteres: duas letras que corespondem aos planetas afetados e um valor entre 1 e 9, que representa o valor da aresta (o nível da ligação interplanetária). Para remover, mesma coisa, com o número 0.

O vetor de planetas deve sumir do programa, sendo substituído por um grafo.
Todo acesso ao grafo deve ser realizado por funções, sem nenhuma que seja específica ao tipo de dados que o grafo está armazenando.
Do ponto de vista do grafo, os nós devem ser do tipo "void \*". A inserção de um nó no grafo deve ser algo como:
```c
  grafo_insere_no(g, planeta_cria(...));
```
A identificação dos nós no grafo é por posição. Por exemplo, para obter o terceiro nó do grafo:
```c
  planeta *p = grafo_no(g, 2);
```
Para a remoção de um planeta do grafo, a memória dele deve ser liberada externamente:
```c
  planeta *p = grafo_remove_no(g, 1);
  planeta_destroi(p);
```

O grafo deve ter a API abaixo:
```c
  /// grafo.h
  /// API simples para grafos não orientados, ed2021a, benhur, dlsc, ufsm
  
  
  /// ------------------------------------------------------------ tipos e constantes
  
  typedef struct grafo grafo;
  
  // um define para poder representar o peso de uma aresta que não existe
  #include <limits.h>
  #define GRAFO_ARESTA_INEXISTENTE INT_MIN
  
  
  /// ---------------------------------------------------------- criação e destruição
  
  // cria um novo grafo não orientado, vazio.
  // retorna um ponteiro para o grafo criado.
  grafo *grafo_cria(void);
  
  // destroi o grafo, liberando a memória ocupada por ele.
  // o grafo não gerencia o uso de memória pelos nós, caso esse controle seja necessário, 
  //   deve ser feito externo ao grafo.
  void grafo_destroi(grafo *g);
  
  
  /// -----------------------------------------------------------------acesso aos nós

  // retorna o número de nós atualmente no grafo
  int grafo_num_nos(grafo *g);
  
  // retorna o n-ésimo nó do grafo g
  // n deve estar entre 0 e um a menos que o número de nós do grafo (retorna NULL se n não for válido)
  void *grafo_no(grafo *g, int n);
  
  // insere um novo nó no grafo
  // retorna a identificação do nó inserido
  // sua identificação será igual ao número de nós no grafo antes da inserção
  //   (se o grafo tem 3 nós, a identificação do novo nó é 3)
  int grafo_insere_no(grafo *g, void *no)
  
  // remove o n-ésimo nó do grafo g
  // retorna o nó removido
  // n deve estar entre 0 e um a menos que o número de nós no grafo (retorna NULL se n não for válido)
  // os nós após n serão renomeados (n+1 passa a ser n, n+2 passa a ser n+1 etc)
  // as arestas ligadas ao nó removido devem ser removidas do grafo
  void *grafo_remove_no(grafo *g, int n);

  
  /// ------------------------------------------------------------- acesso às arestas
  
  // insere uma aresta entre o nó n1 e o nó n2, com o peso fornecido
  // se já existir tal aresta, seu peso é alterado para o fornecido
  // se n1 ou n1 não forem identificações válidas de nós, a aresta não é inserida
  // se o peso for GRAFO_ARESTA_INEXISTENTE, a aresta é removida, se existir
  void grafo_insere_aresta(grafo *g, int n1, int n2, int peso);
  
  // retorna o peso da aresta entre os nós n1 e n2
  // se não existir tal aresta ou tais nós, retorna GRAFO_ARESTA_INEXISTENTE
  int grafo_aresta(grafo *g, int n1, int n2);
  
  // remove a aresta entre os nós n1 e n2, e retorna seu peso
  // se não existir tal aresta ou tais nós, retorna GRAFO_ARESTA_INEXISTENTE
  int grafo_remove_aresta(grafo *g, int n1, int n2);
  
  // inicia o percurso das arestas que partem do nó n no grafo g
  // o acesso às arestas se dá por meio de chamadas a grafo_proxima_aresta
  // caso n não seja válido ou não tenha arestas incidentes, a próxima chamada
  //   a grafo_proxima_aresta deve retornar GRAFO_ARESTA_INEXISTENTE
  void grafo_percorre_arestas(grafo *g, int n);
  
  // retorna a próxima aresta do percurso iniciado por uma chamada a grafo_percorre_arestas
  // coloca em *n o nó que essa aresta interliga
  // retorna o peso da aresta
  // caso não existam mais arestas no percurso, não altera *n e retorna GRAFO_ARESTA_INEXISTENTE
  // esta função não deve ser chamada sem ter havido uma chamada anterior à grafo_percorre_arestas
  // esta função não deve ser chamada após uma chamada a ela retornar GRAFO_ARESTA_INEXISTENTE nem
  //   após alguma chamada que altere o grafo, sem antes chamar grafo_percorre_arestas
  int grafo_proxima_aresta(grafo *g, int *n);
```

O objetivo do usuário do programa é não perder planetas por colisão, nem expandir demais o universo com planetas fujões.


... *continua* ...
